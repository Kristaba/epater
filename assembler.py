import struct
from collections import defaultdict

from lexparser import lexer, MemAccessPreInfo, ShiftInfo, DummyToken, LexError
from instruction import InstructionToBytecode
from settings import getSetting

BASE_ADDR_INTVEC = 0x00
BASE_ADDR_CODE   = 0x80
BASE_ADDR_DATA   = 0x1000


class AssemblerError(Exception):
    def __init__(self, msg):
        super().__init__(msg)

class ParsingError(AssemblerError):
    def __init__(self, msg):
        super().__init__(msg)

class RangeError(AssemblerError):
    def __init__(self, msg):
        super().__init__(msg)

class ParseError:
    dictErrors = {'SYNTAX': "Erreur de syntaxe",
                  'RANGE' : "Erreur de range",
                  'INVINSTR': "Instruction invalide",
                  }

    def __init__(self, etype, msg, gravity="ERROR"):
        self.t = etype
        self.m = msg
        self.gravity = gravity

    def __str__(self):
        return "{} : {}".format(self.t, self.m)

def parse(code):
    """
    Parse and compile ARM assembly code.
    :param code:
    :return: A tuple containing a bytes object (the generated bytecode) and
    a list object which maps each address in the bytecode to a line in the
    provided ARM assembly
    """
    listErrors = []
    if getSetting("PCbehavior") == "real":
        raise NotImplementedError("Actual PC behavior not implemented yet")
    pcoffset = 8 if getSetting("PCbehavior") == "+8" else 0

    # First pass : lexical parsing
    parsedCode = []
    for line in code:
        parsedCode.append([])

        try:
            lexer.input(line)
        except LexError as e:
            listErrors.append(str(e))
            continue
            
        while True:
            tok = lexer.token()
            if not tok:
                break      # End of line
            else:
                parsedCode[-1].append(tok)

    # Second pass : assign memory and define labels
    assignedAddr = [-1]*len(parsedCode)
    addrToLine = defaultdict(list)
    currentAddr, currentSection = -1, None
    labelsAddr = {}
    maxAddrBySection = {"INTVEC": BASE_ADDR_INTVEC,
                        "CODE": BASE_ADDR_CODE,
                        "DATA": BASE_ADDR_DATA}
    snippetMode = False
    for i,pline in enumerate(parsedCode):
        assignedAddr[i] = max(currentAddr, 0)
        addrToLine[max(currentAddr, 0)].append(i)
        if len(pline) == 0:
            # We have to keep these empty lines in order to keep track of the line numbers
            continue
        idxToken = 0

        if pline[0].type == "SECTION":
            assert not snippetMode, "SECTION keyword found in snippet mode!"
            if currentSection is not None:
                maxAddrBySection[currentSection] = currentAddr

            if pline[0].value == "INTVEC":
                currentSection = "INTVEC"
                currentAddr = BASE_ADDR_INTVEC
            elif pline[0].value == "CODE":
                currentSection = "CODE"
                currentAddr = BASE_ADDR_CODE
            elif pline[0].value == "DATA":
                currentSection = "DATA"
                currentAddr = BASE_ADDR_DATA

        if pline[0].type == "LABEL":
            if currentAddr == -1:
                # No section defined, but we have a label; we run in snippet mode
                snippetMode = True
                currentAddr = 0
                currentSection = "SNIPPET_DUMMY_SECTION"
            labelsAddr[pline[0].value] = currentAddr
            idxToken += 1

        if idxToken >= len(pline):
            continue

        if pline[idxToken].type == "DECLARATION":
            if currentAddr == -1:
                # No section defined, but we have a declaration; we run in snippet mode
                snippetMode = True
                currentAddr = 0
                currentSection = "SNIPPET_DUMMY_SECTION"
            psize = pline[idxToken].value.nbits // 8 * pline[idxToken].value.dim
            assert psize <= 8192, "Too large memory allocation requested! ({} bytes)".format(psize)
            currentAddr += psize
        elif pline[idxToken].type == "INSTR":
            if currentAddr == -1:
                # No section defined, but we have an instruction; we run in snippet mode
                snippetMode = True
                currentAddr = 0
                currentSection = "SNIPPET_DUMMY_SECTION"
            currentAddr += 4        # Size of an instruction
    if snippetMode:
        maxAddrBySection = {"SNIPPET_DUMMY_SECTION": currentAddr}
    else:
        maxAddrBySection[currentSection] = currentAddr

    # Third pass : replace all the labels in the instructions
    labelsAddrAddr = {}     # Contains to position of the address of a given label once it have been generated (so we do not generate it again)
    labelsAddrBySection = defaultdict(list)
    currentSection = "SNIPPET_DUMMY_SECTION" if snippetMode else None
    for i,pline in enumerate(parsedCode):
        if len(pline) == 0:
            # We have to keep these empty lines in order to keep track of the line numbers
            continue

        if pline[0].type == "SECTION":
            currentSection = pline[0].value

        for j,token in enumerate(pline):
            if token.type == "REFLABEL":
                addrToReach = labelsAddr[token.value]
                diff = addrToReach - (assignedAddr[i] + pcoffset)
                sign = diff // abs(diff) if diff != 0 else 1
                pline[j] = DummyToken("MEMACCESSPRE",
                                      MemAccessPreInfo(15, "imm", abs(diff), sign, ShiftInfo("LSL", 0)))
            elif token.type == "REFLABELADDR":
                if token.value not in labelsAddrAddr:
                    # We must put the address at the end of the current section
                    # We will have to put these values in memory thereafter
                    labelsAddrAddr[token.value] = maxAddrBySection[currentSection]
                    labelsAddrBySection[currentSection].append(labelsAddr[token.value])
                    maxAddrBySection[currentSection] += 4
                addrToReach = labelsAddrAddr[token.value]
                diff = addrToReach - (assignedAddr[i] + pcoffset)
                sign = diff // abs(diff) if diff != 0 else 1
                pline[j] = DummyToken("MEMACCESSPRE",
                                      MemAccessPreInfo(15, "imm", abs(diff), sign, ShiftInfo("LSL", 0)))

    # Fourth pass : create bytecode
    # At this point, we should have only valid ARM instructions, so let's parse them
    # At the end of each section, we also add the address defined on the previous pass

    # We add a special field in the bytecode info to tell the simulator the start address of each section
    bytecode = {'__MEMINFOSTART': {"SNIPPET_DUMMY_SECTION": 0} if snippetMode else {"INTVEC": BASE_ADDR_INTVEC, "CODE": BASE_ADDR_CODE, "DATA": BASE_ADDR_DATA},
                '__MEMINFOEND': maxAddrBySection}
    currentSection = "SNIPPET_DUMMY_SECTION" if snippetMode else None
    bc = bytes()
    for i,pline in enumerate(parsedCode):
        if len(pline) == 0:
            # We have to keep these empty lines in order to keep track of the line numbers
            continue

        if pline[0].type == "SECTION":
            if currentSection is not None:
                for val in labelsAddrBySection[currentSection]:
                    bc += struct.pack("<I", val)
                bytecode[currentSection] = bc
                bc = bytes()
            currentSection = pline[0].value

        for j,token in enumerate(pline):
            if token.type in ("INSTR", "DECLARATION"):
                bc += InstructionToBytecode(pline[j:])
    bytecode[currentSection] = bc

    return bytecode, addrToLine

